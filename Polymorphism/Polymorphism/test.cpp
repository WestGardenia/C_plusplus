#include<iostream>
#include<vector>
#include<list>

using namespace std;

// 多态：不同的对象去做同一件事会有不同的效果
// 多态的两个条件：
//	1、虚函数的重写
//		虚函数：被virtual修饰的类成员函数称为虚函数
//			在菱形继承中将父类用virtual修饰的叫做虚继承，和虚函数无关是用于解决数据冗余和二义性
//		重写的虚函数必须函数名、参数列表、返回值完全相同
//			派生类的虚函数不加virtual也可以构成重写。但是基类必须要有virtual关键字
//	2、父类对象的指针或者引用去调用虚函数
// 
// 虚函数重写的两个例外：
//	1、协变（基类和派生类的虚函数返回值类型不同）
//		此时，虚函数返回值类型必须是相应类对象的指针或引用
//	2、析构函数的重写
//		虚构函数经过编译器处理后，会构成隐藏――函数名经过处理是相同的
//		当创建的父类对象是用子类构造出来时，如果不用虚函数，那么就会调用的父类析构函数，可能会出现子类的某些资源没有释放
// 满足多态：跟指向的对象有关，指向哪个对象调用的就是他的虚函数
// 不满足多态：跟调用对象的类型有关，类型是什么调用的就是谁的虚函数
// 
// final关键字：用于修饰成员函数和类
//	修饰类：则该类不能被继承
//	修饰虚函数：则该函数不能被重写
// 
// override关键字：用于检查子类的虚函数是否重写了父类的虚函数（防止函数名写错）
// 
// 有一种虚函数叫做纯虚函数――没有对其进行实现的叫做纯虚函数
// 例如：
//		virtual void Drive() = 0;	
//		这样的一个函数叫做纯虚函数
// 当一个类别中包含纯虚函数时，这个类就叫做抽象类
//	抽象类不能进行实例化，同样的，继承抽象类的常规子类也不能进行实例化
// 只有当子类对相应的纯虚函数进行重写后，才能实例化
// 
// 纯虚函数的作用：强制子类去完成重写
// 
// 
// 
// 重载、重写、重定义的对比
// 重载：在同一作用域下，函数名相同
// 重写：在基类和派生类中的两个虚函数，函数名/参数/返回值都要相同（协变除外）	本质就是同一函数的重新定义
// 重定义（隐藏）：不构成重写的，就是重定义。例如不全是虚函数/参数列表不完全相同
//

//class Person
//{
//public:
//	virtual void BuyTicket()
//	{
//		cout << "Person::买票-全价" << endl;
//	}
//};
//class Student:public Person
//{
//public:
//	virtual void BuyTicket()
//	{
//		cout << "Student::买票-半价" << endl;
//	}
//};
//
//void Func(Person& p)	// void Func(Person* p)
//{
//	p.BuyTicket();
//}
//
//int main()
//{
//	Person ps;
//	Student st;
//
//	Func(ps);
//	Func(st);
//	return 0;
//}


class Base
{
private:
	virtual void Func1()
	{
		cout << "Func1()" << endl;
	}
public:
	int _b = 1;
};

int main()
{
	cout << sizeof(Base) << endl;
	// 这里检测类Base的大小，实际上是检查类实例化出来的对象的大小
	// 而Base中，成员变量的大小是int类型的，也就是4字节
	// 成员函数中，有一个虚函数，则实例化后会有一个虚函数表指针，在64位机器下会占据12个字节的大小
	Base b;

	// 对象b中
	// 有成员变量_b
	// 还有虚函数表指针_vftptr  简称虚函数指针

	// 虚函数存在哪？	
	//		虚函数存在代码段
	//		虚函数不是存在虚表中，虚表存放的是虚函数的指针
	// 虚函数表（虚表）存在哪？
	//		虚函数表存在代码段（常量区）中	――	同类型的对象共用一个虚表
	//		同时，虚表中的内容是在编译过程就给好的，运行程序的时候就已经没有办法修改了，就和const对象类似
	return 0;
}